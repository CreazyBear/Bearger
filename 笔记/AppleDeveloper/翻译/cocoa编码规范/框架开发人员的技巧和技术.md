# 框架开发人员的技巧和技术
#程序员/翻译/cocoa编码规范

框架的开发人员在编写代码时必须比其他开发人员更加小心。许多客户端应用程序可以在它们的框架中链接，由于这种广泛的公开，框架中的任何缺陷都可能在整个系统中被放大。下面的项目讨论了可以采用的编程技术，以确保框架的效率和完整性。
> 注意:其中一些技术并不局限于框架。您可以在应用程序开发中有效地应用它们。  

## 初始化
下面的建议和建议包括框架初始化。

### 类初始化
initialize类方法在调用该类的任何其他方法之前惰性地执行一些代码。它通常用于设置类的版本号(请参阅版本控制和兼容性)。
运行时将初始化发送给继承链中的每个类，即使该类没有实现initialize方法；因此，一个类的initialize方法可能会被多次调用(例如，如果子类没有实现它)。通常，您希望初始化代码只执行一次。确保这种情况发生的一种方法是使用dispatch_once():
```obj-c
+ (void)initialize {
    static dispatch_once_t onceToken = 0;
    dispatch_once(&onceToken, ^{
        // the initializing code
    }
}
```

因为运行时将initialize发送给每个类，那么initialize有可能在子类的上下文中被调用。如果您特别需要在相关类的上下文中执行初始化，您可以执行以下检查，而不是使用dispatch_once():
```obj-c
if (self == [NSFoo class]) {
    // the initializing code
}

```

永远不要显式调用initialize方法。如果需要触发初始化，请调用一些无害的方法，例如:
`[NSImage self];`

### 指定的初始化
指定的初始化器是类的init方法，它调用超类的init方法。(其他初始化器调用类定义的init方法。)每个公共类都应该有一个或多个指定的初始化器。作为指定初始化器的例子，有NSView的initWithFrame:和NSResponder的init方法。在不打算覆盖init方法的情况下，就像NSString和其他位于类集群前面的抽象类一样，子类应该实现它自己的方法。

应该清楚地标识指定的初始化器，因为这些信息对于那些想要子类化您的类的人非常重要。子类可以覆盖指定的初始化器，所有其他初始化器将按照设计工作。

当您实现一个框架的类时，您经常需要实现它的归档方法:initWithCoder:和encodeWithCoder:。注意，不要在初始化代码路径中做一些在对象未存档时不会发生的事情。实现这一点的一个好方法是，如果类实现了归档，那么可以从指定的初始化器和initWithCoder:(它本身就是指定的初始化器)调用一个公共例程。

### 初始化期间错误检测
设计良好的初始化方法应完成以下步骤，以确保正确检测和传播错误:
* 通过调用super的指定初始化器重新分配self。
* 检查返回的nil值，这表明在超类初始化中发生了一些错误。
* 如果在初始化当前类时发生错误，释放对象并返回nil
```obj-c
- (id)init {
    self = [super init];  // Call a designated initializer here.
    if (self != nil) {
        // Initialize object  ...
        if (someError) {
            self = nil;
        }
    }
    return self;
}
```

## 版本控制和兼容性
当向框架添加新类或方法时，通常不需要为每个新特性组指定新版本号。开发人员通常执行(或应该执行)Objective-C运行时检查，比如respondsToSelector:判断给定系统上的特性是否可用。这些运行时测试是检查新特性的首选和最动态的方法。
但是，您可以使用几种技术来确保您的框架的每个新版本都有适当的标记，并尽可能与早期版本兼容。

### 框架版本号
当运行时测试无法轻易发现新特性或bug修复时，您应该为开发人员提供一些检查更改的方法。实现这一点的一种方法是存储框架的确切版本号，并使开发人员能够访问这个编号
* 在版本号下记录更改(例如在发布说明中)
* 设置框架的当前版本号，并提供某种方式使其可全局访问。您可以将版本号存储在框架的information属性列表(Info.plist)中并从那里访问它。

### 归档
如果需要将框架的对象写入nib文件，那么它们必须能够对自己进行归档。您还需要对使用归档机制存储文档数据的任何文档进行归档
您应该考虑以下归档问题:
* 如果归档文件中缺少一个键，请求其值将返回nil、NULL、NO、0或0.0，具体取决于请求的类型。测试此返回值以减少所写的数据。此外，您还可以发现是否有一个键被写入存档。
* 编码和解码方法都可以确保向后兼容。例如，类的新版本的encode方法可能使用键来编写新值，但仍然可以写出旧的字段，以便类的旧版本仍然能够理解对象。此外，decode方法可能希望以某种合理的方式处理丢失的值，以便为将来的版本保持一定的灵活性。
* 框架类的存档键的推荐命名约定是从框架的其他API元素使用的前缀开始，然后使用实例变量的名称。只是要确保名称不能与任何超类或子类的名称冲突。
* 如果您有一个实用程序函数，可以写出基本数据类型(换句话说，不是对象的值)，那么一定要使用唯一键。例如，存档一个矩形的“archiveRect”例程应该使用一个键参数，或者使用给定的键，或者，如果它写出多个值(例如，4个浮点数)，它应该在提供的键上附加它自己的唯一位。
* 由于编译器和端到端依赖关系，按原样归档位字段可能很危险。由于性能的原因，您应该只在需要多次写出许多位元时才对它们进行归档。请参阅Bitfields以获得建议。


## 异常和错误
大多数Cocoa框架方法不会强制开发人员捕获和处理异常。这是因为异常并不是执行的正常部分，通常也不用于沟通预期的运行时或用户错误。这些错误的例子包括:
* File not found
* No such user
* Attempt to open a wrong type of document in an application
* Error in converting a string to a specified encoding

但是，Cocoa会抛出异常来指示编程或逻辑错误，比如下面的错误:
* Array index out of bounds
* Attempt to mutate immutable objects
* Bad argument type

开发人员应该在测试过程中捕获这些类型的错误，并在交付应用程序之前解决它们;因此，应用程序不需要在运行时处理异常。如果引发了异常，而应用程序中没有任何部分捕获它，顶级默认处理程序通常捕获并报告异常，然后继续执行。开发人员可以选择将这个默认的异常捕捉器替换为一个提供更多错误细节的异常捕捉器，并提供保存数据和退出应用程序的选项。

错误是Cocoa框架与其他一些软件库不同的另一个领域。Cocoa方法通常不会返回错误代码。在有一个合理或可能的错误原因的情况下，这些方法依赖于一个布尔值或对象(nil/non-nil)返回值的简单测试;记录了返回值为NO或nil的原因。您不应该使用错误代码来指示要在运行时处理的编程错误，而是引发异常，或者在某些情况下，只记录错误而不引发异常。

例如，NSDictionary的objectForKey:方法要么返回找到的对象，要么返回nil，如果它找不到对象的话。NSArray的objectAtIndex:方法永远不能返回nil(除了重写的通用语言惯例，即任何传递给nil的消息都会导致nil返回)，因为NSArray对象不能存储nil值，根据定义，任何越界访问都是编程错误，应该导致异常。当对象不能使用提供的参数初始化时，许多init方法返回nil。

在少数情况下，方法需要多个不同的错误代码，它应该在引用参数中指定它们，引用参数返回错误代码、本地化的错误字符串或描述错误的其他信息。例如，您可能希望将错误作为NSError对象返回;看看NSError。h头文件在基础的细节。这个参数可能是直接返回的简单BOOL或nil的补充。该方法还应该遵守这样的约定，即所有引用参数都是可选的，因此如果发送方不希望知道错误，则允许发送方为error-code参数传递NULL。

## 框架的数据
如何处理框架数据对性能、跨平台兼容性和其他目的都有影响。本节讨论涉及框架数据的技术。

### 常量数据
出于性能方面的原因，最好将尽可能多的框架数据标记为常量，因为这样做会减小`Mach-O`二进制文件的`__DATA`段的大小。非`const`的全局和静态数据最终会出现在`__DATA`段的`__DATA`部分。这种数据占用了使用框架的应用程序的每个运行实例的内存。虽然额外的500字节(例如)看起来并不是很糟糕，但是它可能会导致需要的页面数量的增加——每个应用程序需要额外的4千字节。

您应该将任何不变的数据标记为常量。如果块中没有`char *`指针，这将导致数据落在`__TEXT`段中(这使其真正保持不变);否则，它将留在`__DATA`段中，但不会被写入(除非没有进行预绑定或在加载时必须滑动二进制文件而违反了预绑定)。

您应该初始化静态变量，以确保它们被合并到`__data`段的`__DATA`部分中，而不是`__bss`段中。如果没有用于初始化的明显值，则使用`0、NULL、0.0`或任何适当的值。


### Bitfields
如果代码假定值为布尔值，那么为位字段(特别是位字段为1位)使用带符号的值可能会导致未定义的行为。位字段应该总是无符号的。因为只有0和-1可以存储在这样的位字段中(取决于编译器实现)，所以将这个位字段与1进行比较是错误的。例如，如果您在代码中遇到这样的情况:
```obj-c
BOOL isAttachment:1;

int startTracking:1;

```

这里应该将类型改成`unsigned int`
位字段的另一个问题是存档。通常，您不应该将位字段以它们所在的形式写入磁盘或存档，因为在另一个体系结构或另一个编译器上再次读取它们时，格式可能不同。

### 内存分配
在框架代码中，最好的方法是避免完全分配内存。如果出于某种原因需要临时缓冲区，通常使用堆栈比分配缓冲区要好。然而，堆栈的大小是有限的(通常总共是512KB)，因此使用堆栈的决定取决于函数和所需缓冲区的大小。通常，如果缓冲区大小为1000字节(或MAXPATHLEN)或更小，使用堆栈是可以接受的。

一种改进方法是从使用堆栈开始，但是如果要求的大小超过堆栈的大小，则切换到`malloc` 缓冲区。清单2给出了一个代码片段，可以做到这一点:
```
#define STACKBUFSIZE (1000 / sizeof(YourElementType))
 YourElementType stackBuffer[STACKBUFSIZE];
 YourElementType *buf = stackBuffer;
 int capacity = STACKBUFSIZE;  // In terms of YourElementType
 int numElements = 0;  // In terms of YourElementType
while (1) {
    if (numElements > capacity) {  // Need more room
        int newCapacity = capacity * 2;  // Or whatever your growth algorithm is
        if (buf == stackBuffer) {  // Previously using stack; switch to allocated memory
            buf = malloc(newCapacity * sizeof(YourElementType));
            memmove(buf, stackBuffer, capacity * sizeof(YourElementType));
        } else {  // Was already using malloc; simply realloc
            buf = realloc(buf, newCapacity * sizeof(YourElementType));
        }
        capacity = newCapacity;
    }
    // ... use buf; increment numElements ...
  }
  // ...
  if (buf != stackBuffer) free(buf);
```

## 对象比较
您应该注意到通用对象比较方法isEqual:和与对象类型(如isEqualToString:)关联的比较方法之间的一个重要区别。方法允许您将任意对象作为参数传递，如果对象不是同一个类，则返回NO。诸如isEqualToString:和isEqualToArray:之类的方法通常假设参数是指定类型(即接收者类型)。因此，它们不执行类型检查，因此它们更快，但不那么安全。对于从外部资源(如应用程序的信息属性列表(Info.plist)或首选项)检索的值，最好使用isEqual:因为它更安全;当类型已知时，使用isEqualToString:代替。

关于isEqual还有一点:它与散列方法的连接。对于放入基于哈希的Cocoa集合(比如NSDictionary或NSSet)中的对象，一个基本的不变量是如果[a isEqual:B] == YES，那么[a hash] == [B hash]。因此，如果您重写isEqual:在您的类中，您还应该重写hash以保持这个不变式。默认情况下，isEqual:查找每个对象地址的指针相等，然后哈希返回一个基于每个对象地址的哈希值，因此这个不变式成立。





