SWIFT 基础

1. 类型检查(type checking)
2. 字符串插值——`\(xxx)`
3. 比较运算符：===  !== 计算两个实例是否指向同一个引用
4. switch：这个oc的语法还是有一些改变的
    ```swift
    func testSwitch(_ a:Int) {
        switch a {
        case 100:
            print("full")
        case 1..<10:
            print("one")
        case 10..<20:
            print("two")
        case 20..<30:
            print("three")
            fallthrough
        case 40,50:
            print("4050")
        case let tempA where (tempA > 50 && tempA < 100):
            print("where bind value")
        default:
            print("default \(a)")
        }
    }
    testSwitch(51)
    ```
    1. Switch must be exhaustive: switch必须全覆盖
    2. 所以视情况看是否需要添加default
5. 字符串

    1. 字符串由字符组成
    2. 字符由一个或者多个unicode组成
    3. 标准等价是指两个Unicode标量序列在语言学层面是否相等。对于两个字符或者两个字符串， 如果它们具备相同的语言学含义和外观，那么无论是否用相同的Unicode标量创建，都认为两者相等，并不影响字符串长度计算
    4. String.Index：由于String最基本的单元是Unicode，而一个Unicode可能不等于一个字符。所以无法通过下标的方式对字符串中的字符进行访问。而String.Index则是以Charater为单位的序列。( A position of a character or code unit in a string.)
6. optional 
    1. 可空实例绑定
        ```swift
        var a:String?
        a =  "hello"
        if let b = a { //这里的a必须是一个option type
            print(a)
            print(b)
        }
        //Optional("hello")
        //hello
        ```
    2.如果左边的可空实例是`nil`，那么`??`会返回右边的值。如果左边的可空实例不是nil，那么`??`会返回可空实例中包含的值。
7. 数组和字典略
8. set：合集(union);交集(intersection);差集(isDisjoint)
9. 函数
    1. 变长参数
        ```swift
        func printPersonalGreetings(to names: String...) {
            print(type(of: names))
            for name in names {
                print("Hello \(name), welcome to the playground.")
            }
        }
        printPersonalGreetings(to: "Alex","Chris","Drew","Pat")
        ```

        ```swift
        Array<String>
        Hello Alex, welcome to the playground.
        Hello Chris, welcome to the playground.
        Hello Drew, welcome to the playground.
        Hello Pat, welcome to the playground.
        Program ended with exit code: 0
        ```
    2. 默认参数
        ```swift
        func printPersonalGreetings(to names: String... , defaultValueParam: Int = 34) {
        print(type(of: names))
        for name in names {
            print("Hello \(name), welcome to the playground. \(defaultValueParam)")
            }
        }
        printPersonalGreetings(to: "Alex","Chris","Drew","Pat")
        ```
        默认参数可以放在非默认参数前面，但是参数名不能少，不然，就不知道对应关系了。
    3. in-out
        ```swift
        var error = "The request failed:"
        func appendErrorCode(_ code: Int, toErrorString errorString: inout String) {
            if code == 400 {
                errorString += " bad request."
            }
        }
        appendErrorCode(400, toErrorString: &error)
        print(error)
        ```
        去掉in-out关键字会怎么样？Left side of mutating operator isn't mutable: 'errorString' is a 'let' constant。swift的参数在进到函数内后，都是let类型的。所以需要`inout`关键字加上`&`配合表明这个参数是可以在内部被修改的
    4. 嵌套
        ```swift
        func getDisCount(origin:Double) -> (Double) -> (Double) {
            func disCountType_1(origin:Double) -> Double {
                return origin * 0.9
            }
            
            func disCountType_2(origin:Double) -> Double {
                return origin * 0.8
            }
            
            func disCountType_3(origin:Double) -> Double {
                return origin * 0.7
            }
            if origin < 100 && origin > 0 {
                return disCountType_1(origin:)
            }
            else if origin > 100 && origin < 200 {
                return disCountType_2(origin:)
            }
            else {
                return disCountType_3(origin:)
            }
        }
        print(getDisCount(origin: 101)(101))
        ```
    5. 作用域后面再说了
10. 闭包
    ```swift
    var volunteerCounts = [1,3,40,32,2,53,77,13]
    func sortAscending(_ i: Int, _ j: Int) -> Bool {
        return i < j
    }
    let volunteersSorted = volunteerCounts.sorted(by: sortAscending)
    volunteerCounts.sort()
    print(volunteerCounts)

    volunteerCounts.sort(by: >)
    print(volunteerCounts)

    volunteerCounts.sort(by: <)
    print(volunteerCounts)

    volunteerCounts.sort { (ele1, ele2) -> Bool in
        return ele1 > ele2
    }
    print(volunteerCounts)

    print( volunteerCounts.sorted { (a, b) -> Bool in
        return a > b
    })

    print(volunteerCounts.sorted(by: { (a, b) -> Bool in
    return a > b
    }))
    ```


    var test = {(a:Int) -> Int in
        print("hello \(a)")
        return a
    }
    print(test(10))
    print(type(of: test))
    //hello 10
    //10
    //(Int) -> Int
    ```
    1. 可以看到 `<` 也是函数指针，类似c++了，可以自定义运算符号。
    2. 还有一个概念：尾部闭包语法。
    3. 关键字in用来分隔闭包的参数、返回值和闭包体内的语句。
    4. 函数指针满天飞了
    5. 虽然没有看源码的内部实现，用法上和block差不多，感觉比block还要灵活
    6. 闭包是引用类型
11. 枚举
    ```swift

    enum ProgrammingLanguage: String {
        case swift = "swift"
        case objectiveC = "objective-c"
        case c = "c"
        case cpp = "c++"
        case java = "java"
        
        func sayHello() -> Void {
            
            switch self {
            
            case .swift:
                print("print(\"hello world\")")
            case .objectiveC:
                print("NSLog(\"hello world\")")
            case .c:
                print("printf(\"hello world\")")
            case .cpp:
                print("printf(\"hello world\")")
            case .java:
                print("System.out.printf(\"hello world\")")
            @unknown default:
                print("hello world")
            }
        }
    }
    var myFavoriteLanguage = ProgrammingLanguage.swift
    print(type(of: myFavoriteLanguage))
    print("My favorite programming language is \(myFavoriteLanguage.rawValue)")
    myFavoriteLanguage = .java
    myFavoriteLanguage.sayHello()
    ```
    1. enum终于可以直接把成员名当作string打印出来了
    2. enum可以添加方法，牛逼了，虽然还不知道怎么用。但感觉还是很有用的。
    3. enum的方法有一个隐藏的参数，那就是self。有了self当然就可以特殊处理了
    4. 关联值：不知道怎么用，先不展开了
    5. 由于关联值的出现，引入了递归枚举的问题：解决起来就是使用关键字：indirect

12. 结构体和类

    1. class是类型引用，而struct是值引用
    2. struct没有继承的功能，class有继承功能
    3. 如果结构体的一个实例方法要修改结构体的属性，就需要将方法记为mutating: `Left side of mutating operator isn't mutable: 'self' is immutable`

13. 属性
    1. 存储属性、计算属性    
    2. lazy:属性只会在第一次被访问的时候计算，后面不会再重新计算。
    3. Variable with a setter must also have a getter
    4. 'didSet' cannot be provided together with a getter
    5. 'willSet' cannot be provided together with a getter
    6. ```swift
        struct Person {
        var firstName = "Matt"
        var lastName = "Mathias"
        mutating func changeTo(firstName: String, lastName: String) {
            self.firstName = firstName
            self.lastName = lastName
        }
        
        lazy var age: Int = {
            return 18
        }()
        
        var size: Int {
            return 100
        }
        
        var name: String {
            get {
                return firstName + "-" + lastName
            }
            set {
                self.firstName = newValue
            }
        }
        }
        ```


        var p = Person()
        p.name = "hello"
        print(p.name)
        ```
    7. 静态属性和类型属性最大的区别是静态属性无法被子类覆盖。
14. 访问控制
15. 初始化
    1. 结构体的默认成员初始化方法
    2. 委托初始化方法
    3. 类初始化方法
    4. 指定初始化方法
    5. 便捷初始化方法
    7. 必要初始化方法
    8. deinit
    9. 可失败的初始化方法
16. 协议 
17. 异常处理
18. 泛型
19. extension
20. 协议扩展
21. 还有内存管理、闭的一些更高级的使用。

之前在学习C++时，泛型展现了强大的灵活性，在一些场景下非常有用。协议和扩展打破了oop的固有模式，struct+protocol构成swift面向协议语言的两个基石。在设计代码结构和框架的时候，如果完全照搬OC的那一套，那代码就没有特性了。现在只是大概看了下swift的语法基础，看内心还是激动的，这门语言强大、灵活而且安全。只是在写代码的时候，xcode在闭包的代码提示总是出现问题。期待后面会更好。


