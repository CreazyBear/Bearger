# 计算机硬件结构

![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E6%89%AB%E6%8F%8F%E6%96%87%E7%A8%BF%201.jpg)

# 提高CPU利用率


多道：当一个程序不使用CPU时，让出
分时：每个程序执行一段时间后主动让出
分任务：每个程序都执行一个时间片，操作系统快速切换任务，使得程序像是在一直执行

# 线程的同步与锁


由于多个线程的寄存器是共用的所以多个线程访问寄存器的时候可能会出现问题，这个时候需要在多个线程之间进行同步。
线程同步有以下几种方式：二元信号量，多元信号量，互斥量，临界区，读写锁，条件变量（事件）

二元信号量和多元信号量算是类，前者只能一次一个线程访问，后者可以多个线程访问！

信号量和互斥量和差异在于互斥量释放必须和获取的线程一致！

临界区不能夸进程访问，其他的和互斥量类似，性能上比互斥量好点

读写锁主要提高读写I/o的效率，读写锁有两种状态：共享的，独占的

条件变量感觉和事件类似


四种进程或线程同步互斥的控制方法
1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。 
4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

关于编译器的过度优化，volatile 
当编译器判断现场会频繁访问一个变量的时候，会将这个变量存储到当前线程的寄存器中。如果这个变量是一个存储在堆内的全局变量，这时候会出现线程问题。




# 线程


#### 进程与线程的关系

线程间共享代码段，数据段，堆
独立的寄存器和栈
![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%9B%BE%E5%83%8F.png)

#### 线程状态切换
![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%9B%BE%E5%83%8F%202.png)


#### Windows 和Linux对于进程和线程的差异
![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%9B%BE%E5%83%8F%203.png)


#### 多线程的内容实现

我们开发人员所接触到的线程是指用户态的用户线程，而底层则是去对应到操作系统的内核线程。

￼
![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Pasted%20Graphic.tiff)
￼

![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Pasted%20Graphic%201.tiff)


![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Pasted%20Graphic%202.tiff)



# 计算机软件层次结构



![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/%E5%9B%BE%E5%83%8F%204.png)


软件框架设计中问题，没有什么是增加一个层次结构解决不了的，如果是，那再加一层~！ 2333

# 编译过程


预编译
* 展开宏
* 将#include插入文件
* 处理#ifdef ….
* 去掉注释



编译
* 词法分析 得到分词
* 语义分析 得到语法树
* 语法分析 类型转换，类型匹配，进一步完善语法树
* 中间代码生成 对语法树进行平台无关的优化精简
* 目标代码生成与优化

汇编
将汇编代码转换成机器码

链接
（这是一个复杂的过程）


汇编后我们得到一个目标文件，这个文件和最终的可执行文件已经很类似了。


关于源代码中的符号，页面内的全局符号会被保留到目标文件的符号表中，最后由链接器进行处理。而局部就是的符号由汇编器在汇编阶段就处理了。
汇编语言支持符号变量（这一特性并不是一开始就有的，而是后来添加上的）

关于目标文件中有哪些段，各段的中有哪些属性，各属性有什么含义，不同平台有不同的处理，所以，23333。书中也只能找到大概的意思。不过可以通过变量名猜测。。。。

# 内存管理


内存管理

解决三个问题：
* 隔离：每个程序使用的内存地址需要隔离
* 内存使用率
* 程序运行地址不确定
		* 这一点很重要。在后面的编译链接时都用到的地址，而这些地址都是虚拟地址。所以可以保证编译链接的正确进行



使用虚拟地址和分页技术




# 链接


链接 是一个相当复杂的过程，其中的细节我就不看了  =。=


但链接所做的事，大体就是将之前定义的全局符号进行替换，并重定位。以使得程序在运行时能找到正确的变量和方法。

# 装载



回忆一下：源代码经过  预处理，编译，汇编，链接  之后生成了一个可执行文件。
这个文件还只是一个静态的文件。要执行起来需要加载 到内存中。加载程序到内存就涉及到虚拟内存，分页，啥的。但这一处理过程已经被移动操作系统了。所以程序本身已经不再关心。


# 动态链接

之前所讲到的都是静态链接过程。

![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Pasted%20Graphic%203.tiff)

所谓动态链接并不是说程序运行起来了再去链接需要的库，而是操作系统先分析执行文件，查看是否需要链接动态库，如果需要，先由操作系统将动态库准备好。等动态库也链接好了，再将程序启动。可以看出，这是一个链接滞后的过程，也可以说是二次链接

由于链接的动态库不在目标文件中，而是程序运行时加载的，所以有很高的灵活性

![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Pasted%20Graphic%204.tiff)
￼


# OSI七层网络结构

![](%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/784487-20170118164512515-2009100776.png)

