# iOS-Objective-C中的那些设计模式
#程序员/iOS/设计模式

# 一、 几种基本且通用的设计模式
![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1822069-3fa8222188bd376d.jpg)


# 二、设计的基本原则

1. 单一职责原则：

　　也就是我们常说的一个类负责一个职责，虽然这个对于程序猿们是一个常识，但是事件经常会发展到我们无法控制的地步。
　　比如刚开始的时候类T只负责一个职责P。后来由于某种原因，也许是需求变更了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）

2. 里氏替换原则：

　　这项原则最早是在1988年，由麻省理工学院的Barbara Liskov女士提出来的。
　　定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。
　　定义2：所有引用基类的地方必须能透明地使用其子类的对象。
　　看完定义大致也知道这个是个和继承相关的定义。其实就是我们通常::使用继承时子类尽量不要去修改父类的功能::。这也是为什么我们在继承父类方法进行扩展的时候通常都会代用super的原因。

3. 依赖倒置原则：

　　定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。（抽象指的是接口或者抽象类，细节就是具体的实现。）
　　在面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。
> 没有什么问题是增加一层所不能解决的，如果不能，那么再增加一层  
其实就是在实现之间注意添加接口，在iOS中可以当成是面向协议编程

4. 接口隔离原则：

　　定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
　　还是以苹果的UITableViewDelegate为例，在设计时定义了部分必须实现的基本方法（最小接口）。那么其他的接口只需要在必要时才实现。而不是需要实现所有接口才能使用某个功能。
> iOS-Objective-C的协议方法有两种类型：必选和可选。并且协议是可以继承的。  

5. 迪米特法则：

　　定义：一个对象应该对其他对象保持最少的了解。
　　问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
　　解决方案：尽量降低类与类之间的耦合。
　　软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。
　　迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。

> 就目前的经验来看，日常代码中最常见的问题就是`ObjectA.ObjectB.ObjectC`，也就是A中通过成员变量B，直接访问B的成员变量C。这到后期维护升级的时候就坑了。  
> A对B知道的越少越好，B暴露的接口越少越好，如果可以的话面向接口编程  


6. 开闭原则：

　　开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的，即修改原有的代码对外部的使用是透明的。

> Objective-C的语言特性使得对类进行功能扩展很方便：extension & category。但如果需要对修改封闭，就需要在设计时面向接口编程，或者尽可能少的暴露细节。  

当我们使用category有个问题：属性无法正常添加（虽然可以通过associate进行关联）
之前在阅读RN代码时，发出有种方式可以不用关联来添加属性。RN代码中将category和protocol进行联合使用。来达到对类型进行功能扩展。即在protocol中声明属性和方法，然后在要扩展的类中声明实现协议，最后在category中实现就好了。这样category和protocol相互为一套功能扩展。category中所用到的成员变量和接口声明在protocol中，被扩展的类通过协议来扩展功能，并不添加多余的属性。


# 三、iOS中常用的几种设置模式

## 单例
呃，略......
`NotificationCenter` `NSUserDefault`

## 代理
场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是那个类实现。

优势： 解耦合

敏捷原则：开放--封闭原则

实例：tableview的数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate，自定义的delegate


## 观察者

场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。

优势：解耦合

敏捷原则：接口隔离原则，开放-封闭原则

实例：
1. Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。

2. KVO，键值对改变通知的观察者

## MVC

场景：是一种非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。

优势：使系统，层次清晰，职责分明，易于维护

敏捷原则：对扩展开放-对修改封闭

实例：model-即数据模型，   view-视图展示，  controller进行UI展现和数据交互的逻辑控制。


## 策略

场景：定义算法族，封装起来，使他们之间可以相互替换。

优势：使算法的变化独立于使用算法的用户

敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。

实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。

## 工厂模式
工厂模式主要是为创建对象提供了接口。
1. 简单工厂模式(Simple Factory)
2. 工厂方法模式(Factory Method)
3. 抽象工厂模式(Abstract Factory)
在什么样的情况下我们应该记得使用工厂模式呢？大体有两点：
1. 在编码时不能预见需要创建哪种类的实例。
2. 系统不应依赖于产品类实例如何被创建、组合和表达的细节

### 简单工厂模式
![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/44BA14AE-73AE-4552-8F3B-513C0CD77365.png)
网上找了一个图，大概就是这样的。
客户端（FactoryClient）负责给出产品参数
工厂（SimpleFactory）负责生产指定对象并返回
客户端得到对象后就可以直接使用了

这样做的好处首先是职责的化分，客户不用关心产品是如何生成的，只需要给出需要什么样的产品，而工厂就只需要根据客户给出的参数生成产品返回给客户，最后客户根据产品的功能进行使用。

但简单工厂模式中工厂的实现中有一个很大的问题：代码中需要根据客户给出的参数来判断生产哪个产品，这在代码层面就是一堆的if-else  or switch。每一次添加产品都需要个性工厂代码。这很不开闭。

所以，当产品不常发生变更的时候，简单工厂足以。

### 工厂方法模式
![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7F8E3FD8-1F73-4A80-841E-E66D0CB86441.png)

工厂方法模式就是对工厂进行抽象来解决简单工厂的缺点。
::说明::：在简单工厂中，一个工厂负责生产多种型号的产品。而在工厂方法中，一个工厂只负责生产指定型号的产品。分工更加细致。在扩展的时候只需要声明实现抽象工厂接口就可以。

一个典型的应用：Class Cluster
> The Foundation framework has class clusters for NSString, NSData, NSDictionary, NSSet, and NSArray objects. The public superclasses include these immutable classes as well as the complementary mutable classes NSMutableString, NSMutableData, NSMutableDictionary, NSMutableSet, and NSMutableArray.  

![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/BB657D76-BD33-4C72-8F60-53F7E5969125.png)



### 抽象工厂模式


![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4ACC6BD332B71C9FEC15C969F4B5ACF3.jpeg)
工厂方法模式中，一个工厂只能生产一种类型的产品。而如果客户需求不是按产品类型来提出的，而是按产品功能来提出的。例如，客户需要选择一辆跑车，要知道各大汽车制造商都是有生产跑车的。这个时候，抽象工厂模式所做的就是将同一功能类型的产品集中。方便客户选择产品。
我的个人理解是，抽象工厂模式是简单工厂模式和工厂方法模式的组合。
对于上图我们简单修改就可以得到简单工厂和工厂方法的UML图了。
1. 我们去掉抽象产品A，那么这个图就和工厂方法模式一致了。
2. 对于工厂1，这就是一个简单工厂模式。

工厂模式是一个创建模式，具体使用哪一个需要根据产品复杂度和用户需求来判断。

### 外观模式
通过下面这个例子可能比类图更容易理解。
![](iOS-Objective-C%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/402B0A37-6946-472C-A401-DA5D662EED81.png)

### 装饰模式
就是动态的给一个对象添加一些额外的职责或者是功能，装饰模式比生成子类更为灵活。是给已有功能动态的添加更多功能的一种方式。举一个装修房子的例子来说明一下什么是装饰模式. 

Category 就是一个典型的应用。

当我们使用代理模式的时候，需要设置代理 。对于MVC模式来说，代理可以设置成Controller。但代理一但多了，会导致Controller变得臃肿。这时可以使用装饰模式将代理移到其它类中。

### 适配器模式
Objective-C中使用Protocol来现实这一模式。
UITableViewDelegate, UIScrollViewDelegate, NSCoding and NSCopying. 


### 备忘录模式
将状态保存，在需要的时候取出之前的状态。
eg：在一个列表页面，用户滑动一段距离后，离开了当前页面。那么可以在离开 的时候将状态保存到NSUserDefault中。在下次再进入的时候读取状态。
Apple中的归档（NSKeyedArchiver）就是这一模式的典型应用

### 命令模式
NSInvocation 一个典型的命令模式。将操作封装到对象中，然后将命令发送到指定对象上。还可以对指令进行相关操作。

### 责任链模式
典型应用：Responder Chain