# Kick off xib/sb

## 背景

之前在做Clipber的时候，使用xib开发UI界面，xib在个人开发时还是很爽的，特别是绘制UI的时候。但在[Clipber开发总结](../Clipber/Clipber开发总结.md)中也提到了xib的一些问题。所以，想探索一下Mac上使用纯代码开发的方式。

## 一、从`AppDelegate`开始

与`AppDelegate`相关的是main.xib。要使用纯代码开发的话，这里先把main.xib中的window干掉。然后与之关联的`AppDelegate`中的window属性干掉。

像iOS应用开发一样，窗口由我们自己写
```objc
@interface AppDelegate ()
@property (nonatomic, strong) FJViewController *homeVC;
@property (nonatomic, strong) NSWindow * rootWindow;
@property (nonatomic, strong) NSWindowController *rootWindowController;
@end

- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    self.homeVC = [[FJViewController alloc] initWithFrame:NSMakeRect(100, 100, 500, 500)];
    
    self.rootWindow = [NSWindow windowWithContentViewController:self.homeVC];
    self.rootWindowController = [[NSWindowController alloc]initWithWindow:self.rootWindow];
    
    [self.rootWindow makeKeyWindow];
    self.rootWindow.title = @"Menu Lab";
    [self.rootWindow center];
    [self.rootWindowController showWindow:nil];
    
}

```
上面的代码，可以界面展示，但有几个问题：

1. 如果不显示创建`View`实例，当把VC加载到`window`对象中时，系统会报`-[NSNib _initWithNibNamed:bundle:options:] could not load the nibName: FJViewController in bundle (null)`
2. `loadView`没有被执行
3. `FJViewController`的`initWithFrame`是我自己写的初始化方法
4. `FJViewController`的`ViewDidLoad`不走了


## 二、怎么创建View

对于第一个问题，查看了一下Apple文档中的描述，`[NSWindow windowWithContentViewController:self.homeVC]`这个方法将VC的View做为自己的ContentView，而如果没有的话，Window就无法显示。所以，可以理解为强依赖的关系。所以，可以理解为只要保证在调用前将View设置好就不会有这个异常了？代码如下：
```objc
- (void)applicationDidFinishLaunching:(NSNotification *)aNotification {
    self.homeVC = [FJViewController new];
    NSView * vcView = [[NSView alloc] initWithFrame:NSMakeRect(100, 100, 500, 500)];
    self.homeVC.view = vcView;
    self.rootWindow = [NSWindow windowWithContentViewController:self.homeVC];

    self.rootWindowController = [[NSWindowController alloc] initWithWindow:self.rootWindow];
    
    [self.rootWindow makeKeyWindow];
    self.rootWindow.title = @"Bearger";
    [self.rootWindow center];
    [self.rootWindowController showWindow:nil];
}
```
结果如预期的一样，没有抛出异常

按xib的方式，我们在新建VC的时候对应创建与之关联的xib文件。在初始化VC的时候，通过`initWithNibName:bundle:`方法进行初始化。`NSViewController`的这个初始化方法做了什么呢？为啥在OSX中的ViewDidLoad不走，但在iOS中是可以走的？

针对第二个问题，我尝试换了一种写法：
```objc
@implementation FJViewController
- (void)loadView {
    // [super loadView];
    NSView * vcView = [[NSView alloc] initWithFrame:NSMakeRect(100, 100, 200, 200)];
    self.view = vcView;
}
@end
```
将原来放在init中创建的View放在loadView方法中

1. loadView什么时候被调用的？

    下面是loadView断点的调用栈。
    ```objc
    * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    * frame #0: 0x00000001000021b8 NSViewControllerDemo`-[FJViewController loadView](self=0x0000600002911260, _cmd="loadView") at FJViewController.m:39:17
        frame #1: 0x00007fff3f72ed7c AppKit`-[NSViewController _loadViewIfRequired] + 72
        frame #2: 0x00007fff3f72ecea AppKit`-[NSViewController view] + 30
        frame #3: 0x00007fff3fe96b1b AppKit`+[NSWindow windowWithContentViewController:] + 41
        frame #4: 0x0000000100001c0a NSViewControllerDemo`-[AppDelegate applicationDidFinishLaunching:](self=0x000060000022bbe0, _cmd="applicationDidFinishLaunching:", aNotification=@"NSApplicationDidFinishLaunchingNotification") at AppDelegate.m:32:23
    ```
    按文档中所说的：` If you require this method to be called, access the view property`。所以，可以理解为，当访问VC的View对象时就会调用。实验代码如下，loadView在被第一次访问的时候调用了。

    ```objc
   - (void)applicationDidFinishLaunching:(NSNotification *)aNotification {

    // self define init
    self.homeVC = [FJViewController new];
    self.homeVC.view; // ----这里直接访问一次
    
    self.rootWindow = [NSWindow windowWithContentViewController:self.homeVC];
    self.rootWindowController = [[NSWindowController alloc] initWithWindow:self.rootWindow];
    
    [self.rootWindow makeKeyWindow];
    self.rootWindow.title = @"Bearger";
    [self.rootWindow center];
    [self.rootWindowController showWindow:nil];
    }


    // bt

      * frame #0: 0x00000001000021a8 NSViewControllerDemo`-[FJViewController loadView](self=0x00006000029004d0, _cmd="loadView") at FJViewController.m:39:17
    frame #1: 0x00007fff3f72ed7c AppKit`-[NSViewController _loadViewIfRequired] + 72
    frame #2: 0x00007fff3f72ecea AppKit`-[NSViewController view] + 30
    frame #3: 0x0000000100001b8e NSViewControllerDemo`-[AppDelegate applicationDidFinishLaunching:](self=0x0000600000216540, _cmd="applicationDidFinishLaunching:",
    ```
    
    这里和iOS的UIViewController有点不同：NSViewController的初始化方法不会调用View。但UIViewController会。
    ```objc
    * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 3.1
    * frame #0: 0x000000010889cedc FJQRScan`-[FJHomeViewController loadView](self=0x00007fc4d6707600, _cmd="loadView") at FJHomeViewController.m:25:1
    frame #1: 0x00000001138f3d04 UIKitCore`-[UIViewController loadViewIfRequired] + 172
    frame #2: 0x00000001138f4524 UIKitCore`-[UIViewController view] + 27
    frame #3: 0x000000010889ec5c FJQRScan`-[AppDelegate application:didFinishLaunchingWithOptions:](self=0x0000600001cbd360, _cmd="application:didFinishLaunchingWithOptions:", 
    ```
    所以，这个场景下iOS和OSX的差异就在于第一次访问View的时候会不会默认创建一个View。对比iOS和OSX中的调用可以发现代码应该就是在`_loadViewIfRequired，loadViewIfRequired`。

    根据上面的分析，推断OSX中View的get方法：
    ```objc
    -(NSView *)view{
        if (!_view) {
            [self loadView];
            [self viewDidLoad];
        }
        return _view;
    }
    ```
    所以，只要View是nil，那么，loadView就会被反复调用。

2. 需不需要调用super

   根据文档上所说的，不能直接调用loadView方法，但没有明确说不能调用super。那么super中做了什么呢？根据文档中所描述的，super会加载nib，并创建NSNib对象。但由于我并没有创建xib文件，所以这里肯定是加载不到的。所以，当调用super时，也报错了：`-[NSNib _initWithNibNamed:bundle:options:] could not load the nibName: FJViewController in bundle (null)`。是的，可以理解为报错。因为，执行了`[super viewDidLoad];`后，loadView中后面的代码就执行不了了。

    继续看一下官方文档` This method is called by the system, and is exposed in this class so you can override it to add behavior immediately before or after nib loading`。因为nib的加载和创建是在super中执行的，如果我们没有xib那就不要了，但如果我们有xib，并且需要在xib加载前后做一些事情，那就需要调用了。在nib前执行就写在`[super viewDidLoad]`前面，反之亦然。

3. loadView为啥不被调用了呢？

    上面已经解释了，loadView是在什么时候被调用的。那现在不被调用，当然就是View访问出了问题。其实这个就是一个基础的accessor语法问题了。loadView的调用在View的getter方法中，（_view无法访问）所以当我们对View进行赋值的进修，就会直接走setter方法，而不会走getter方法。之后，当我们再通过self.view访问的时候，因为view已经被实例化过了，所以不会再走创建流程了。导致loadView不会被调用

4. ViewDidLoad不走的原因和loadView的原因是一样的

了解了上面的种种，对最开始的代码进行一下变更
```objc

@interface FJViewController ()
@property (nonatomic, assign) CGRect initFrame;
@end

@implementation FJViewController

- (instancetype)initWithFrame:(NSRect)frame
{
    self = [super init];
    if (self) {
        self.initFrame = frame;
    }
    return self;
}

- (void)loadView {
    if (CGRectIsNull(self.initFrame) || CGRectIsEmpty(self.initFrame) || CGRectIsInfinite(self.initFrame)) {
        self.initFrame = CGRectMake(0, 0, 100, 100);
    }
    NSView * vcView = [[NSView alloc] initWithFrame:self.initFrame];
    self.view = vcView;
}

- (void)viewDidLoad {
    [super viewDidLoad];
}

@end

```

以上，NSViewController就可以走完整个生命周期了。


## 三、布局

上面只是开头，但有了容器，其它都好说。布局上，直接使用第三方库就好了，当然，原生库也不是不可以。对于ObjectiveC可以使用[Masonry](https://github.com/SnapKit/Masonry)，对于Swift可以使用[SnapKit](https://github.com/SnapKit/SnapKit)。

## 四、西瓜刀小试

简单写了一个TableView

```objc
@interface FJViewController ()<NSTableViewDelegate,NSTableViewDataSource>
@property (nonatomic, assign) CGRect initFrame;
@property (nonatomic, strong) NSTableView *tableView;
@end

@implementation FJViewController

- (instancetype)initWithFrame:(NSRect)frame
{
    self = [super init];
    if (self) {
        self.initFrame = frame;
    }
    return self;
}

- (void)loadView {
    if (CGRectIsNull(self.initFrame) || CGRectIsEmpty(self.initFrame) || CGRectIsInfinite(self.initFrame)) {
        self.initFrame = CGRectMake(0, 0, 100, 100);
    }
    NSView * vcView = [[NSView alloc] initWithFrame:self.initFrame];
    self.view = vcView;
    
    NSScrollView * tableContainer = [[NSScrollView alloc] initWithFrame:self.view.bounds];
    self.tableView = [[NSTableView alloc] initWithFrame:self.view.bounds];
    NSTableColumn * column1 = [[NSTableColumn alloc] initWithIdentifier:@"Col1"];
    [column1 setWidth:self.view.frame.size.width];
    [self.tableView addTableColumn:column1];
    
    self.tableView.delegate = self;
    self.tableView.dataSource = self;
    
    [tableContainer setDocumentView:self.tableView];
    [tableContainer setHasVerticalScroller:YES];
    [self.view addSubview:tableContainer];
    
}

- (void)viewDidLoad {
    [super viewDidLoad];
}

-(void)viewWillAppear {
    [super viewWillAppear];
}

-(void)viewDidAppear {
    [super viewDidAppear];
}

-(void)viewWillDisappear {
    [super viewWillDisappear];
}

-(void)viewDidDisappear {
    [super viewDidDisappear];
}

#pragma mark - NSTableViewDelegate,NSTableViewDataSource

-(NSInteger)numberOfRowsInTableView:(NSTableView *)tableView {
    return 111;
}

-(NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row {
    NSView * v = [tableView makeViewWithIdentifier:NSStringFromClass(self.class) owner:self];
    if (!v) {
        v = [NSView new];
    }
    NSTextField * t = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, self.view.frame.size.width, 20)];
    t.textColor = [NSColor blackColor];
    t.stringValue = [NSString stringWithFormat:@"%ld",row];
    [v addSubview:t];
    return v;
}
```
