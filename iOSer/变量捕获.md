# 变量捕获
#程序员/iOS/Block


## 自动变量
> 在函数中定义局部变量时，如果没有被声明为其他类型的变量都是自动变量。在编写代码时，有时需要在调用函数中的某个局部变量以后，这个变量的值不消失，并且保持原值不变，也就是该函数所占用的存储空间不被释放，在下次调用该函数时，变量中的值是上次调用该函数结束时变量的值。这时，使用的变量类型是静态变量，使用static 关键字进行声明。  

同样的例子：
```objc
-(void)start {
    
    int age = 10;
    void (^testBlock)(void) = ^{
        NSLog(@"age:%d",age);
    };
    testBlock();
}
```


```cpp
struct __BlockDemo__start_block_impl_0 {
  struct __block_impl impl;
  struct __BlockDemo__start_block_desc_0* Desc;
  int age;
  __BlockDemo__start_block_impl_0(void *fp, struct __BlockDemo__start_block_desc_0 *desc, int _age, int flags=0) : age(_age) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```

对比cpp源代码，可以看到age这个值被复制到Block内部。
那么下面这个问题就变得再清楚不过了。
```objc
-(void)start {
    
    int age = 10;
    void (^testBlock)(void) = ^{
        NSLog(@"age:%d",age);
    };
    age = 20;
    testBlock();
}

```

最后打印的`age`为10。对比cpp源代码可以看一下。testBlock在创建的时候已经将age的值放复制到内部。所以，testBlock在捕获自动变量的时候进行的是值复制。不是一个变量了。
```cpp
struct __BlockDemo__start_block_impl_0 {
  struct __block_impl impl;
  struct __BlockDemo__start_block_desc_0* Desc;
  int age;
  __BlockDemo__start_block_impl_0(void *fp, struct __BlockDemo__start_block_desc_0 *desc, int _age, int flags=0) : age(_age) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __BlockDemo__start_block_func_0(struct __BlockDemo__start_block_impl_0 *__cself) {
  int age = __cself->age; // bound by copy

        NSLog((NSString *)&__NSConstantStringImpl__var_folders_k5_4r1bsz6j5f9fcb_rgsn5402h0000gn_T_BlockDemo_9fbd49_mi_1,age);
    }

static void _I_BlockDemo_start(BlockDemo * self, SEL _cmd) {

    int age = 10;
    void (*testBlock)(void) = ((void (*)())&__BlockDemo__start_block_impl_0((void *)__BlockDemo__start_block_func_0, &__BlockDemo__start_block_desc_0_DATA, age));
    age = 20;
    ((void (*)(__block_impl *))((__block_impl *)testBlock)->FuncPtr)((__block_impl *)testBlock);
}
```


- - - -
## 静态变量
把上面的例子改一下下
```objc
-(void)start {
    
    static int age = 10;
    void (^testBlock)(void) = ^{
        NSLog(@"age:%d",age);
    };
    age = 20;
    testBlock();
}
```

按static的特性，这里应该打印20。如果不是，那就太不static了。对比cpp代码看下实现
```cpp
struct __BlockDemo__start_block_impl_0 {
  struct __block_impl impl;
  struct __BlockDemo__start_block_desc_0* Desc;
  int *age;
  __BlockDemo__start_block_impl_0(void *fp, struct __BlockDemo__start_block_desc_0 *desc, int *_age, int flags=0) : age(_age) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};

static void __BlockDemo__start_block_func_0(struct __BlockDemo__start_block_impl_0 *__cself) {
  int *age = __cself->age; // bound by copy

        NSLog((NSString *)&__NSConstantStringImpl__var_folders_k5_4r1bsz6j5f9fcb_rgsn5402h0000gn_T_BlockDemo_632fb5_mi_1,(*age));
    }

static void _I_BlockDemo_start(BlockDemo * self, SEL _cmd) {

    static int age = 10;
    void (*testBlock)(void) = ((void (*)())&__BlockDemo__start_block_impl_0((void *)__BlockDemo__start_block_func_0, &__BlockDemo__start_block_desc_0_DATA, &age));
    age = 20;
    ((void (*)(__block_impl *))((__block_impl *)testBlock)->FuncPtr)((__block_impl *)testBlock);
}

```

如你所见，它取了变量的地址，所以是将变更的存储地址复制到内部，这是一个浅拷贝。

- - - -
## 全局变量
呃，这个我觉得不用说了，全局变量可以直接访问，还复制啥?

|**变量类型**|**是否捕获到block内部**|**访问方式**|
|-|-|-|
|局部变量auto	|是|值传递|
|局部变量static|是|指针传递|
|全局变量|否|直接访问|

- - - -

## self变量
这个是在开发过程中用得最多的。来瞅一瞅

```
-(void)start {
    
    void (^testBlock)(void) = ^{
        NSLog(@"height:%@",self);
    };
    testBlock();
}

```


```cpp

static instancetype _I_BlockDemo_init(BlockDemo * self, SEL _cmd) {
    self = ((BlockDemo *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass("BlockDemo"))}, sel_registerName("init"));
    if (self) {
        ((void (*)(id, SEL, NSString *))(void *)objc_msgSend)((id)self, sel_registerName("setName:"), (NSString *)&__NSConstantStringImpl__var_folders_k5_4r1bsz6j5f9fcb_rgsn5402h0000gn_T_BlockDemo_cdb884_mi_0);
    }
    return self;
}



struct __BlockDemo__start_block_impl_0 {
  struct __block_impl impl;
  struct __BlockDemo__start_block_desc_0* Desc;
  BlockDemo *self;
  __BlockDemo__start_block_impl_0(void *fp, struct __BlockDemo__start_block_desc_0 *desc, BlockDemo *_self, int flags=0) : self(_self) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __BlockDemo__start_block_func_0(struct __BlockDemo__start_block_impl_0 *__cself) {
  BlockDemo *self = __cself->self; // bound by copy

        NSLog((NSString *)&__NSConstantStringImpl__var_folders_k5_4r1bsz6j5f9fcb_rgsn5402h0000gn_T_BlockDemo_cdb884_mi_1,self);
    }
static void __BlockDemo__start_block_copy_0(struct __BlockDemo__start_block_impl_0*dst, struct __BlockDemo__start_block_impl_0*src) {_Block_object_assign((void*)&dst->self, (void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void __BlockDemo__start_block_dispose_0(struct __BlockDemo__start_block_impl_0*src) {_Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);}

static void _I_BlockDemo_start(BlockDemo * self, SEL _cmd) {

    void (*testBlock)(void) = ((void (*)())&__BlockDemo__start_block_impl_0((void *)__BlockDemo__start_block_func_0, &__BlockDemo__start_block_desc_0_DATA, self, 570425344));
    ((void (*)(__block_impl *))((__block_impl *)testBlock)->FuncPtr)((__block_impl *)testBlock);
}
```

方法start中的self是哪里来的？OBJC在方法传递的时候会把self和cmd作为形参添加到目标函数中。所以，self是一个局部变量。
从上面的cpp代码可以看到，创建Block的时候对self进行了一次浅拷贝。所以引用计数进行了加一。


这时候我们再看看 循环引用。下面这个循环引用非常明显。
```objc
@interface BlockDemo()
@property (nonatomic, copy) void(^myBlock)(void);
@end

@implementation BlockDemo
-(void)start {
    
    self.myBlock = ^{
        NSLog(@"height:%@",self);
    };
    self.myBlock();
}

-(void)dealloc {
    NSLog(@"dealloc");
}
@end

```

再看一下加上weak之后，循环引用没有了。
```objc
-(void)start {
    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        NSLog(@"height:%@",weakSelf);
    };
    self.myBlock();
}

-(void)dealloc {
    NSLog(@"dealloc");
}
@end

```

呃，c++ clang不过，所以。。。。。。

```
__weak typeof(self) weakSelf = self;
```
先看下这行代码是干啥的吧。
首先`self`是啥？形参。这里把形参`self`复值给了`weakSelf`。那么这里，其实就是`__weak`是干啥的。

> ARC以后引入了__weak的概念来修饰Objective-C对象,使用这个关键字修饰的对象,对象的引用计数不会+1，  
> 在对象释放的时候__weak会将引用的对象置为nil  

所以，我理解，weakSelf和self都是指向同一块内存址，但是，内存块的引用计数没有增加。所以，引用计数可以减到0。
所以，在外层添加weak可以解决这类循环引用的问题。

但是，‘’在对象释放的时候__weak会将引用的对象置为nil“，这个又会带来另一个问题。如果当前`block`超出对象本身的生命周期存在，那对象是不是就会对被设置成nil。

```objc
typedef void(^VoidBlock)(void);
VoidBlock test () {
    BlockDemo * demo = [BlockDemo new];
    [demo start];
    dispatch_block_t block = demo.myBlock;
    return block;
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        VoidBlock block = test();
        block();
    }
    return 0;
}

@interface BlockDemo : NSObject
-(void)start;
@property (nonatomic, copy) void(^myBlock)(void);
@end

@implementation BlockDemo
-(void)start {
    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        NSLog(@"%@",weakSelf);
    };
}

-(void)dealloc {
    NSLog(@"dealloc");
}
@end
```


```
2019-02-26 23:59:45.262315+0800 ObjectiveCLab[7178:882569] dealloc
2019-02-26 23:59:45.262536+0800 ObjectiveCLab[7178:882569] (null)
2019-02-26 23:59:45.262549+0800 ObjectiveCLab[7178:882569] end
Program ended with exit code: 0
```

是的，`block`内部的`weakself`已经被设置成nil了。

很明显，在多数场景下，这不是我们想要的。所以，就有了第二步:`__strong`
`__strong`是干啥的？解决的是什么问题？

> __strong在Block内部修饰的对象,会保证,在使用这个对象在scope内,这个对象都不会被释放  
> 出了scope,引用计数就会-1,且__strong主要是用在多线程运用中  

把上面稍做修改：
```objc
-(void)start {
    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        __strong BlockDemo * strongSelf = weakSelf;
        NSLog(@"%@",strongSelf.name);
    };
}
```

结果并没有改变，对象还是被释放了（结果我就不放了）。那`strong`有啥用？strong是用来解决异步操作的问题。比如网络请求。下面来模拟一下

```objc
typedef void(^VoidBlock)(void);
VoidBlock test () {
    BlockDemo * demo = [BlockDemo new];
    [demo start];
    dispatch_block_t block = demo.myBlock;
    block();
    return block;
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        test();
        NSLog(@"done call test");
        while (1) {   
        }
    }
    return 0;
}


@interface BlockDemo()
@end

@implementation BlockDemo
-(void)start {
    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        __strong BlockDemo * strongSelf = weakSelf;
        dispatch_queue_t queue = dispatch_queue_create("com.bearger.block", DISPATCH_QUEUE_CONCURRENT);
        dispatch_sync(queue, ^{
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{
                NSLog(@"%@",strongSelf);
            });
        });
    };
    self.myBlock();
}

-(void)dealloc {
    NSLog(@"dealloc");
}
@end

```

test执行结束后，BlockDemo做为局部对象就会被干掉。但这个时候因为block已经被执行了。这里对weakSelf进行了一次strong操作。所以block不结束，对象不会被释放。
```
*2019-02-27 00:34:08.953003+0800 ObjectiveCLab[7581:906588] done call test*
*2019-02-27 00:34:14.926047+0800 ObjectiveCLab[7581:906620] <BlockDemo: 0x100642090>*
*2019-02-27 00:34:14.926149+0800 ObjectiveCLab[7581:906620] dealloc*

```

把strong干掉后的结果来看一下
```
*2019-02-27 00:37:15.926034+0800 ObjectiveCLab[7614:908674] dealloc*
*2019-02-27 00:37:15.926279+0800 ObjectiveCLab[7614:908674] done call test*
*2019-02-27 00:37:19.220840+0800 ObjectiveCLab[7614:908737] (null)*
*Program ended with exit code: 9*
```


这里需要注意一下，strong作用的对象：weakSelf，而不是self。
在block外层，通过weak对self进行弱引用，然后在内部，对弱引用的weakSelf进行强引用，保证weak的第二个特性（在对象释放的时候__weak会将引用的对象置为nil）被滞后执行。（block底层是如何实现的，我是不知道啦。）

下面再把上面的例子改一下下：
```objc
-(void)start {
    __weak typeof(self) weakSelf = self;
    self.myBlock = ^{
        __strong BlockDemo * strongSelf = weakSelf;
        dispatch_queue_t queue = dispatch_queue_create("com.bearger.block", DISPATCH_QUEUE_CONCURRENT);
        dispatch_sync(queue, ^{
            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{
                NSLog(@"%@",strongSelf);
                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), queue, ^{
                    NSLog(@"%@",strongSelf);
                });
            });
        });
    };
    self.myBlock();
}

```

是的，Block嵌套。2333！可以理解为接口的回调里再调接口。那么这个时候，我们应该如何处理呢？嵌套的block需不需要weak和strong来处理呢？
先来看一下上面的结果：
```
*2019-02-27 00:47:20.036106+0800 ObjectiveCLab[7659:914407] done call test*
*2019-02-27 00:47:23.322536+0800 ObjectiveCLab[7659:914428] <BlockDemo: 0x100635db0>*
*2019-02-27 00:47:26.622439+0800 ObjectiveCLab[7659:914428] <BlockDemo: 0x100635db0>*
*2019-02-27 00:47:26.622495+0800 ObjectiveCLab[7659:914428] dealloc*
*Program ended with exit code: 9*
```

呃，看来是不用了。23333

不用weak是因为内部嵌套再多也已经不会对最外面的形参self进行引用计数加1
不有strong是因为block没有执行结束，所以最外层捕获的weakSelf会一直存在。


- - - -
## __block
对比一下看加__block和不加的差别。加了block，其实是把变量封装到一个结构体中。
```cpp
struct __Block_byref_age_0 {
  void *__isa;
__Block_byref_age_0 *__forwarding;
 int __flags;
 int __size;
 int age;
};


static void _I_BlockDemo_start(BlockDemo * self, SEL _cmd) {
    __attribute__((__blocks__(byref))) __Block_byref_age_0 age = {(void*)0,(__Block_byref_age_0 *)&age, 0, sizeof(__Block_byref_age_0), 10};
    dispatch_block_t testBlock = ((void (*)())&__BlockDemo__start_block_impl_0((void *)__BlockDemo__start_block_func_0, &__BlockDemo__start_block_desc_0_DATA, (__Block_byref_age_0 *)&age, 570425344));
    ((void (*)(__block_impl *))((__block_impl *)testBlock)->FuncPtr)((__block_impl *)testBlock);
}

```


```cpp
static void _I_BlockDemo_start(BlockDemo * self, SEL _cmd) {
    int age = 10;
    dispatch_block_t testBlock = ((void (*)())&__BlockDemo__start_block_impl_0((void *)__BlockDemo__start_block_func_0, &__BlockDemo__start_block_desc_0_DATA, age));
    ((void (*)(__block_impl *))((__block_impl *)testBlock)->FuncPtr)((__block_impl *)testBlock);
}
```

以下内容copy from www
1.__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。
2.__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。
3.__block对象可以在block中被重新赋值，__weak不可以。
4.__block对象在ARC下可能会导致循环引用，非ARC下会避免循环引用，__weak只在ARC下使用，可以避免循环引用。
