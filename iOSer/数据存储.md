# 数据存储
#程序员/iOS/数据

iOS中承诺关键的数据保存方式有六种：
* NSUserDefaults:
* 归档
* 文件保存
* sqlite数据库——iOS数据库
* CoreData
* KeyChain

iPhone沙盒模型的有四个文件夹，分别是documents，tmp，app，Library。1、Documents 目录：应用程序数据文件在这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。
2、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。不能进行修改，否则程序不会运行。
3、Library 目录：这个目录下有两个子目录：Caches 和 PreferencesPreferences 目录：包含应用程序的偏好设置文件。不能直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好属性.Caches 目录：用于存放缓存文件，保存应用程序再次启动过程中需要的信息。SDWebImage第三方库的缓存信息处理都在这个文件中，一般的大容量文件都放在这里。
4、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。Nsuserdefaults保存的文件一般在tmp文件夹里。



- - - -
### NSUserDefaults> 

> 1. NSUserDefaults不能保存自定义对象。  
> 2. 一般保存用户名，密码，设置项(是否记住密码、是否在2G/3G自动下载图片，是否离线下载等)  
> 3. 保存基本数据类型NSString,NSArray,NSDictionary，用法简单，一般保存少量的数据。  

NSArray和NSDictionary的嵌套是不可以做的

用法：
```objective-c
//保存

[[NSUserDefaults standardUserDefaults] setObject: forKey:];

//取值

[[NSUserDefaults standardUserDefaults] objectForKey:];

//立即保存

[[NSUserDefaultsstandardUserDefaults]synchronize];

//移除

[[NSUserDefaults standardUserDefaults] removeObjectForKey:];
```

- - - -
### 归档> 保存自定义的对象，而且也是保存少量数据。相对于在使用plist进行数据存储和读取，只适用于系统自带的一些常用类型才能用，且必须先获取路径相对麻烦，且只能存储常用类型。

```objective-c
//需要实现NSCoding中的协议的两个方法

- (id)initWithCoder:(NSCoder *)aDecoder{

if (self == [super init]) {

self.name = [aDecoder decodeObjectForKey:Name];

self.sex = [aDecoder decodeObjectForKey:Sex];

self.age = [[aDecoder decodeObjectForKey:Age] integerValue];

}

return self;

}

- (void)encodeWithCoder:(NSCoder *)aCoder{

[aCoder encodeObject:self.name forKey:Name];

[aCoder encodeObject:self.sex forKey:Sex];

[aCoder encodeObject:[NSNumber numberWithInteger:self.age] forKey:Age];

}

//归档

NSMutableData *data = [[NSMutableData alloc] init];

//创建归档辅助类

NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];

//编码

[archiver encodeObject:model forKey:@"model"];

//结束编码

[archiver finishEncoding];

//写入到沙盒

NSArray *array =NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);

NSString *fileName = [array.firstObject stringByAppendingPathComponent:@"archiverModel"];

if([data writeToFile:fileName atomically:YES]){

NSLog(@"归档成功");

}

//解档

NSData *undata = [[NSData alloc] initWithContentsOfFile:fileName];

//解档辅助类

NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:undata];

//解码并解档出model

TestModel *unModel = [unarchiver decodeObjectForKey:@"model"];

NSLog(@"%@",unModel);

//关闭解档

[unarchiver finishDecoding];

```

- - - -
### 文件保存> 一般在iOS常用的是plist，一般也是保存少量数据。一般保存数据类NSArray,NSDictioanary.此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息

- - - -
### sqlite数据库——iOS数据库> 采用SQLite数据库来存储数据。SQLite作为一中小型数据库，应用ios中，跟前三种保存方式相比，相对比较复杂一些。适合保存大量数据，而且sql增删改查操作系统都做了优化。需要写sql语句。

- - - -
### CoreData> 对sqlite的一个包装，系统会自动把实体转为sql语句。好处使用简单，而且不需要写sql语句。适合保存大量数据。

- - - -
### KeyChain> 超过沙盒范围的保存方式，一般保存数据是：app删除了，但是数据不删除。一般保存隐私数据(用户密码，token, cookie)

- - - -

### cache

```objective-c

	// 写缓存
	- (void)writeLocalCacheData:(NSData *)data withKey:(NSString *)key {

	    // 设置存储路径
	    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] 
	                                                                         stringByAppendingPathComponent:key];

	    // 判读缓存数据是否存在
	    if ([[NSFileManager defaultManager] fileExistsAtPath:cachesPath]) {

	        // 删除旧的缓存数据
	        [[NSFileManager defaultManager] removeItemAtPath:cachesPath error:nil];
	    }

	    // 存储新的缓存数据
	    [data writeToFile:cachesPath atomically:YES];
	}

	// 读缓存
	- (NSData *)readLocalCacheDataWithKey:(NSString *)key {

	    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] 
	                                                                         stringByAppendingPathComponent:key];

	    // 判读缓存数据是否存在
	    if ([[NSFileManager defaultManager] fileExistsAtPath:cachesPath]) {

	        // 读取缓存数据
	        return [NSData dataWithContentsOfFile:cachesPath];
	    }

	    return nil;
	}

	// 删缓存
	- (void)deleteLocalCacheDataWithKey:(NSString *)key {

	    NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] 
	                                                                         stringByAppendingPathComponent:key];

	    // 判读缓存数据是否存在
	    if ([[NSFileManager defaultManager] fileExistsAtPath:cachesPath]) {

	        // 删除缓存数据
	        [[NSFileManager defaultManager] removeItemAtPath:cachesPath error:nil];
	    }
	}

```