# 状态栏
#程序员/iOS/视图组件

1. 配置项(info.plist)
```
	<key>UIViewControllerBasedStatusBarAppearance</key>
	<true/>
```

> Apps default to using the new view controller-based status bar management system. To opt out of this, add a value of NO for the UIViewControllerBasedStatusBarAppearance key to your Info.plist.  

  `UIViewControllerBasedStatusBarAppearance`默认是`true`
当`UIViewControllerBasedStatusBarAppearance == true`的时候，`ViewController`和`NavigationController`才能对`StatueBar`的前景样式进行更改。
当`UIViewControllerBasedStatusBarAppearance == false`的时候，需要`Application`级别对其进行修改才能生效。

  `Applicaiton`级别的两种修改方式
	* info.plist（当然这里可以直接在xcode->target->deployinfo->statue bar style中直接设置）
```
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleLightContent</string>
```
	* UIAplication
```
//9以后被遗弃了
application.setStatusBarStyle(.default, animated: false)
```

2. `ViewController`中对`StatueBar`进行修改
  在ViewController中重写相应的方法并调用需要更新
```swift
    override var preferredStatusBarStyle: UIStatusBarStyle{
        return .lightContent
    }
    
    override var prefersStatusBarHidden: Bool{
        return true
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        //通知系统咱需要更新状态栏
        self.setNeedsStatusBarAppearanceUpdate()
    }
```
完成了上一步后，重写的两个方法没有导航的情况下是可以的。可是一但加了导航`NavigationController`，` self.setNeedsStatusBarAppearanceUpdate()`之后，系统会调用导航控制器中的`preferredStatusBarStyle`和`prefersStatusBarHidden`。所以，还需要继承导航控制器并重写相应的方法：
```swift
class BearNavigationViewController: UINavigationController {

    override func viewDidLoad() {
        super.viewDidLoad()

        // Do any additional setup after loading the view.
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    //就是这两个方法
    override var childViewControllerForStatusBarStyle: UIViewController?{
        return self.topViewController
    }
    override var childViewControllerForStatusBarHidden: UIViewController?{
        return self.topViewController
    }
}
```