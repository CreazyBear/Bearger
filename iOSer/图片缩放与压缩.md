# 图片缩放与压缩
#程序员/iOS/视图组件

逛推酷的时候看了这哥们写的《[图片压缩逻辑](http://www.jianshu.com/p/7533ed993130?utm_source=tuicool&utm_medium=referral)》，感觉还不错，于是自己用`swift`重写了下，并进行了一点修改。
直接上代码：
```swift
//  Created by Bear on 2017/3/23.
//  Copyright © 2017年 BeargerHunter. All rights reserved.
//

import Foundation
import UIKit

extension UIImage{
    
    /**
     图片压缩的逻辑:
     一:图片尺寸压缩 主要分为以下几种情况 一般参照像素为targetPx
     a.图片宽高均≤targetPx时，图片尺寸保持不变;
     b.宽或高均＞targetPx时 ——图片宽高比≤2，则将图片宽或者高取大的等比压缩至targetPx; ——但是图片宽高比＞2时，则宽或者高取小的等比压缩至targetPx;
     c.宽高一个＞targetPx，另一个＜targetPx，--图片宽高比＞2时，则宽高尺寸不变;--但是图片宽高比≤2时,则将图片宽或者高取大的等比压缩至targetPx.
     
     二:图片质量压缩: 对于超过大小阈值的图片进行质量压缩，但不保证压缩后的大小
     一般图片质量都压缩在90%就可以了
     */
    open func confressImageView(targetPx:CGFloat, thresholdSize_KB:Int = 200)->Data?
    {
        var newImage:UIImage!  // 尺寸压缩后的新图片
        let imageSize:CGSize = self.size // 源图片的size
        let width:CGFloat = imageSize.width // 源图片的宽
        let height:CGFloat = imageSize.height // 原图片的高
        var drawImge:Bool = false    // 是否需要重绘图片 默认是NO
        var scaleFactor:CGFloat = 0.0   // 压缩比例
        var scaledWidth:CGFloat = targetPx   // 压缩时的宽度 默认是参照像素
        var scaledHeight:CGFloat = targetPx  // 压缩是的高度 默认是参照像素

        if width <= targetPx,height <= targetPx {
            newImage = self
        }
        else if width >= targetPx , height >= targetPx {
            drawImge = true
            let factor:CGFloat = width / height
            if factor <= 2 {
                // b.1图片宽高比≤2，则将图片宽或者高取大的等比压缩至targetPx
                scaleFactor = width > height ? targetPx/width : targetPx/height
            } else {
                // b.2图片宽高比＞2时，则宽或者高取小的等比压缩至targetPx
                scaleFactor = width > height ? targetPx/height : targetPx/width
            }
            
        }
        // c.宽高一个＞targetPx，另一个＜targetPx 宽大于targetPx
        else if width >= targetPx , height <= targetPx {
            if width / height > 2 {
                newImage = self;
            } else {
                drawImge = true;
                scaleFactor = targetPx / width;
            }
        }
        // c.宽高一个＞targetPx，另一个＜targetPx 高大于targetPx
        else if width <= targetPx , height >= targetPx {
            if height / width > 2 {
                newImage = self;
            } else {
                drawImge = true;
                scaleFactor = targetPx / height;
            }
        }
        
        // 如果图片需要重绘 就按照新的宽高压缩重绘图片
        if drawImge {
            scaledWidth = width * scaleFactor;
            scaledHeight = height * scaleFactor;
            UIGraphicsBeginImageContext(CGSize(width:scaledWidth,height:scaledHeight));
            // 绘制改变大小的图片
            self.draw(in: CGRect.init(x: 0, y: 0, width: scaledWidth, height: scaledHeight))
            // 从当前context中创建一个改变大小后的图片
            newImage = UIGraphicsGetImageFromCurrentImageContext();
            // 使当前的context出堆栈
            UIGraphicsEndImageContext();
        }
        // 如果图片大小大于200kb 在进行质量上压缩
        var scaledImageData:Data? = nil;
        guard newImage != nil else {
            return nil;
        }

        if (UIImageJPEGRepresentation(newImage!, 1) == nil) {
            scaledImageData = UIImagePNGRepresentation(newImage);
        }else{
            scaledImageData = UIImageJPEGRepresentation(newImage, 1);
            guard scaledImageData != nil else {
                return nil
            }
            if scaledImageData!.count >= 1024 * thresholdSize_KB {
                scaledImageData = UIImageJPEGRepresentation(newImage, 0.9);
            }
        }
   
        return scaledImageData
    }
    
}
```