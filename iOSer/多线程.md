# 多线程


# iOS中多线程的实现方案

1. pthread

a. 特点：
1）一套通用的多线程API
2）适用于Unix\Linux\Windows等系统
3）跨平台\可移植
4）使用难度大
b.使用语言：c语言
c.使用频率：几乎不用
d.线程生命周期：由程序员进行管理

2. NSThread

a.特点：
1）使用更加面向对象
2）简单易用，可直接操作线程对象
b.使用语言：OC语言
c.使用频率：偶尔使用
d.线程生命周期：由程序员进行管理

3. GCD

a.特点：
1）旨在替代NSThread等线程技术
2）充分利用设备的多核（自动）
b.使用语言：C语言
c.使用频率：经常使用
d.线程生命周期：自动管理

4. NSOperation

a.特点：
1）基于GCD（底层是GCD）
2）比GCD多了一些更简单实用的功能
3）使用更加面向对象
b.使用语言：OC语言
c.使用频率：经常使用
d.线程生命周期：自动管理

对于第一种没啥好说的，太底层，基本用不到

- - - -

# NSThread
#### eg:
```
-(void)createNSThread{
    NSThread * threadOne = [[NSThread alloc]initWithBlock:^{
        [self nsthreadRun:@"thread one"];
    }];
    
    NSThread * threadTwo = [[NSThread alloc]initWithTarget:self selector:@selector(nsthreadRun:) object:@"thread two"];
    
    [threadOne start];
    [threadTwo start];
    
    [NSThread detachNewThreadSelector:@selector(nsthreadRun:) toTarget:self withObject:@"thread three"];
    
}

-(void)nsthreadRun:(NSString*)param{
    NSLog(@"%@",param);
}

```

使用起来很简单，看下文档基本就会了。

#### 设置线程的属性
```
//设置线程的名称
thread.name = @"线程A";
//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5
thread.threadPriority = 1.0;
```


#### 常用的控制线程状态的方法
```
[NSThread exit];//退出当前线程
[NSThread sleepForTimeInterval:2.0];//阻塞线程
[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程
```


- - - -

# GCD

- - - -

# NSOperation
1. NSOperation本身是抽象类，只能只有它的子类
2. 三个子类分别是：`NSBlockOperation`、`NSInvocationOperation`以及自定义继承自`NSOperation`的类
3. `NSOperation`和`NSOperationQueue`结合使用实现多线程并发

这里有一片文章可以学习一下。

> [iOS多线程--彻底学会多线程之『NSOperation』](http://www.jianshu.com/p/4b1d77054b35)  


之前写了一个swift版本的。凑合看吧~!
#### 一. 基本用法

如果不创建BlockOperation，那么任务直接被分配到start被调用的线程。

addExecutionBlock的异步并发执行，可能在主线程也可能在别的线程。

```swift
        let blockOperation = BlockOperation.init {
            print("Simple Demo----\(Thread.current)\n")
        }
        
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----0----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----1----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----2----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----3----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----4----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----5----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----6----\(Thread.current)\n")
        }
        blockOperation.addExecutionBlock {
            print("ExecutionBlock----7----\(Thread.current)\n")
        }
        blockOperation.start()
	
```



output:

```
ExecutionBlock----2----<NSThread: 0x60000026f480>{number = 4, name = (null)}

Simple Demo----<NSThread: 0x60800007e780>{number = 1, name = main}

ExecutionBlock----0----<NSThread: 0x608000267ec0>{number = 5, name = (null)}

ExecutionBlock----4----<NSThread: 0x60800007e780>{number = 1, name = main}

ExecutionBlock----6----<NSThread: 0x60800007e780>{number = 1, name = main}

ExecutionBlock----3----<NSThread: 0x608000267ec0>{number = 5, name = (null)}

ExecutionBlock----5----<NSThread: 0x60000026f480>{number = 4, name = (null)}

ExecutionBlock----7----<NSThread: 0x60800007e780>{number = 1, name = main}

ExecutionBlock----1----<NSThread: 0x608000267e80>{number = 3, name = (null)}



```



#### 二. 任务队列

如果创建OperationQueue.main，那么所有任务将在主线程中串行异步执行。

如果是非主线程队列，那么任务并发异步执行。

addExecutionBlock是并发异步，不受控制

为了实现在非主线程队列的串行异步执行，需要设置`queue.maxConcurrentOperationCount`

```swift
        let queue = OperationQueue.init()
//        let queue = OperationQueue.main
        queue.maxConcurrentOperationCount = 1
        print("start-------")
        
        queue.addOperation { 
            print("addOperation----1----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----11----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----1111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----11111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----111111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----1111111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----11111111----\(Thread.current)\n")
        }
        queue.addOperation {
            print("addOperation----111111111----\(Thread.current)\n")
        }
        
        print("end-------")
```



#### 三. 操作依赖

```swift

        let queue = OperationQueue.init()
        print("start-------")

        let operation1 = BlockOperation.init { 
            print("operation---1---\(Date.init())---\(Thread.current)")
        }
        let operation2 = BlockOperation.init {
            print("operation---2---\(Date.init())---\(Thread.current)")
            sleep(3)
        }
        let operation3 = BlockOperation.init {
            print("operation---3---\(Date.init())---\(Thread.current)")
        }
        
        operation2.addDependency(operation1)
        operation3.addDependency(operation2)
        
        queue.addOperation(operation1)
        queue.addOperation(operation2)
        queue.addOperation(operation3)
        print("end-------")

```



output:

```
start-------
end-------
operation---1---2017-08-10 05:15:49 +0000---<NSThread: 0x6000000767c0>{number = 3, name = (null)}
operation---2---2017-08-10 05:15:49 +0000---<NSThread: 0x6000000767c0>{number = 3, name = (null)}
operation---3---2017-08-10 05:15:52 +0000---<NSThread: 0x60800007bdc0>{number = 4, name = (null)}

```



#### 四. KVO

官方文档中可以查到更多的支持KVO的属性。当自己写Operation的子类时，需要注意处理各状态

```swift
    
    //MARK: - Operation
    func operationDemo() {
        
        let queue = OperationQueue.init()
        print("start-------")

        let operation1 = BlockOperation.init { 
            print("operation---1---\(Date.init())---\(Thread.current)")
        }
        let operation2 = BlockOperation.init {
            print("operation---2---\(Date.init())---\(Thread.current)")
            sleep(3)
        }
        let operation3 = BlockOperation.init {
            print("operation---3---\(Date.init())---\(Thread.current)")
        }
        
        operation2.addDependency(operation1)
        operation3.addDependency(operation2)
        
        
        operation2.addObserver(self, forKeyPath: "isFinished", options: .new, context: nil)
        
        
        queue.addOperation(operation1)
        queue.addOperation(operation2)
        queue.addOperation(operation3)
        print("end-------")
        
    }
    
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "isFinished"
        {
            print("\(String(describing: change?[NSKeyValueChangeKey.newKey]))")
        }
    }

```

output:

```
start-------
end-------
operation---1---2017-08-10 05:33:26 +0000---<NSThread: 0x60800007bd00>{number = 3, name = (null)}
operation---2---2017-08-10 05:33:26 +0000---<NSThread: 0x60800007bd00>{number = 3, name = (null)}
operation---3---2017-08-10 05:33:29 +0000---<NSThread: 0x608000072e80>{number = 4, name = (null)}
Optional(1)

```



- - - -

一个问题：如何创建一个指定线程数的线程池？
1. 个人觉得可以使用NSThread封装一个，当然使用pThread也可以~！
2. ` let queue = OperationQueue.init()  let queue = OperationQueue.main queue.maxConcurrentOperationCount = 1`
